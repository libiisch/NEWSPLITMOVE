#include <Wire.h>

#define STEPX_PIN 4
#define DIRX_PIN 10
#define STEPY_PIN 11
#define DIRY_PIN 8

#define limbX 3 // "limb" stands for "limit button", therfore limit button X.
#define limbY 5 // limit button Y.

int spin = 40; // One full step for HALF stepper motor steps
const int VRX_PIN = A0;
const int VRY_PIN = A1;
const int SW_PIN = 7;
int Xcoords = 0;
//bool globalBTNPress = false; 

//int MOVEMENT_BACKWARDS = -1; // When axis is -1, the motor moves in the opposite direction (backwards).
int NO_MOVEMENT = 0;         // When axis is 0, the motor doesn't receive a step pulse, so it doesn't move.
//int MOVEMENT_FORWARDS = 1;   // In the doMove() function, when the axis value is 1 the motor moves in forward.

unsigned long lastClickedX = millis(); // Store the current time in milliseconds
unsigned long lastClickedY = millis(); // Store the current time for Y as well

void setup() {
  pinMode(STEPX_PIN, OUTPUT);
  pinMode(DIRX_PIN, OUTPUT);
  pinMode(STEPY_PIN, OUTPUT);
  pinMode(DIRY_PIN, OUTPUT);

  pinMode(limbX, INPUT_PULLUP); // Neutral state = 1 for limit button X
  pinMode(limbY, INPUT_PULLUP); // Neutral state = 1 for limit button Y

  Serial.begin(9600);
  Serial.println("setup finished, wait for home.");

  attachInterrupt(digitalPinToInterrupt(limbX), btnClickedX, FALLING); // Whenever limbX is in falling state, activate ISR btnClickedX.
  attachInterrupt(digitalPinToInterrupt(limbY), btnClickedY, FALLING); // Whenever limbY is in falling state, activate ISR btnClickedY.

  home(); // Resets x,y's positions to their set home every upload.
}

void loop() {
  checkMovementX();
  checkMovementY();

}


void btnClickedX() { // Not only - but also a debouncer.
  unsigned long currentTime = millis(); // New value in millis to represent the current time in millis since upload.

  if (currentTime - lastClickedX > 100) { // If the last click happened more than 100 millis ago, accept new one.
    XREVERSE(); // *******this is the X reverse function to call a reverse movement when limbX is pressed. this switch the globalBTNPress method.********
    
    lastClickedX = currentTime; // Sets the last click's timestamp to the latest timestamp a click has occured on.
  }
}

void btnClickedY () {
  unsigned long currentTime = millis();

  if(currentTime - lastClickedY > 100) {
    YREVERSE(); // *******this is the Y reverse function to call a reverse movement when limbY is pressed. this switch the globalBTNPress method.********

    lastClickedY = currentTime; // Sets the last click's timestamp to the latest timestamp a click has occured on.
  }
}

int checkMovementX() {
  int x = analogRead(VRX_PIN);

  if (x > 600) {
    MOVEX(spin, 300, HIGH);
  } else if (x < 400) {
    MOVEX(spin, 300, LOW);
  } else {
    return NO_MOVEMENT;
  }
}

int checkMovementY() {
  int y = analogRead(VRY_PIN);

  if (y > 600) {
    MOVEY(spin, 300, HIGH);
  } else if (y < 400) {
    MOVEY(spin, 300, LOW);
  } else {
    return NO_MOVEMENT;
  }
}


void MOVEX(int steps, int speed, bool direction) {
  digitalWrite(DIRX_PIN, direction);
  digitalWrite(STEPX_PIN, steps);

  for (int i = 0; i < steps; i++) {
    digitalWrite(steps, HIGH);
    delayMicroseconds(speed);
    digitalWrite(steps, LOW);
    delayMicroseconds(speed);
  }
}

void XREVERSE() {
  MOVEX(100, 300, LOW);
}


void MOVEY(int steps, int speed, bool direction) {
  digitalWrite(DIRY_PIN, direction);
  digitalWrite(STEPY_PIN, steps);

  for (int i = 0; i < steps; i++) {
    digitalWrite(steps, HIGH);
    delayMicroseconds(speed);
    digitalWrite(steps, LOW);
    delayMicroseconds(speed);
  }
}

void YREVERSE() {
  MOVEY(100, 300, LOW);
}

void home() {
  Serial.println("starting home");
  MOVEX(8000, 300, HIGH);   // true = x
  MOVEY(8000, 300, HIGH);  // false = y
}

